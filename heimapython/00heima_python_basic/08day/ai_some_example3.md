# 🌀 递归大法：从阶乘到不死神兔的神奇循环


## 🌟 先搞懂：递归是个啥？

你有没有玩过“俄罗斯套娃”？一个大娃娃里套着一个小娃娃，小娃娃里又套着更小的……递归就像这种“自己包含自己”的结构——**函数自己调用自己**。

但递归可不是瞎套娃，它有两个必须遵守的“铁律”：  
1. **必须有出口**：不能无限套下去，否则会“撑爆”内存（栈溢出）；  
2. **必须有规律**：每次调用都要解决一个更小的问题，最终靠近出口。  

记住这两点，递归就不难啦！


## 一、递归求阶乘：数学里的“套娃游戏”

### 🎯 问题：什么是阶乘？
阶乘是数学里的概念，比如“5的阶乘”（写作5!）就是从5乘到1：  
`5! = 5 × 4 × 3 × 2 × 1`  

那n的阶乘呢？就是`n! = n × (n-1) × (n-2) × ... × 1`  


### 🚩 递归思路：拆分成“更小的阶乘”
仔细看阶乘的计算，会发现一个规律：  
`5! = 5 × 4!`（5的阶乘 = 5 × 4的阶乘）  
`4! = 4 × 3!`（4的阶乘 = 4 × 3的阶乘）  
...  
`1! = 1`（1的阶乘就是1，没法再拆了）  

所以：  
- **出口**：当n=1时，返回1（1! = 1）；  
- **规律**：n! = n × (n-1)!（n的阶乘 = n乘以n-1的阶乘）。  


### 💻 代码实战（逐行解析）
```python
# 定义函数：计算n的阶乘
def factorial(n):
    # 出口：n=1时，直接返回1（不用再拆了）
    if n == 1:
        return 1
    # 规律：n! = n × (n-1)!，自己调用自己算(n-1)!
    return n * factorial(n - 1)

# 测试：计算5的阶乘
if __name__ == '__main__':
    print(factorial(5))  # 输出：120（因为5! = 5×4×3×2×1=120）
```


### 🧠 递归过程拆解（以5!为例）
就像拆快递，一层一层拆到最后：  
```
factorial(5)  
= 5 × factorial(4)  
= 5 × (4 × factorial(3))  
= 5 × (4 × (3 × factorial(2)))  
= 5 × (4 × (3 × (2 × factorial(1))))  
= 5 × (4 × (3 × (2 × 1)))  # 触发出口，开始往回算  
= 5 × (4 × (3 × 2))  
= 5 × (4 × 6)  
= 5 × 24  
= 120  
```


## 二、斐波那契数列：不死神兔的繁殖之谜

### 🎯 问题：不死神兔的故事
传说有一对小兔子，遵循以下规律繁殖：  
1. 小兔子1个月后长成大兔子；  
2. 大兔子每个月生1对小兔子；  
3. 所有兔子都不死。  

问：1年后（12个月）有多少对兔子？  


### 📊 规律分析：月份与兔子对数的关系
我们列个表观察（“对”为单位）：  

| 月份 | 小兔子对数 | 大兔子对数 | 总对数 |  
|------|------------|------------|--------|  
| 1月  | 1（刚生的） | 0          | 1      |  
| 2月  | 0（长成大兔子） | 1          | 1      |  
| 3月  | 1（大兔子生的） | 1          | 2      |  
| 4月  | 1（上月大兔子生的） | 2（上月大兔子+上月小兔子长大） | 3 |  
| 5月  | 2（上月2对大兔子各生1对） | 3（上月大兔子+上月小兔子长大） | 5 |  
| 6月  | 3 | 5 | 8 |  

发现了吗？从3月开始，**当月总对数 = 上月总对数 + 上上月总对数**！  
比如：3月=2月+1月（1+1=2），4月=3月+2月（2+1=3），5月=4月+3月（3+2=5）……  


### 🚩 递归思路：用前两个月推当前月
- **出口**：1月和2月的总对数都是1（没有更早的月份了）；  
- **规律**：第m个月的对数 = 第(m-1)个月的对数 + 第(m-2)个月的对数。  


### 💻 代码实战（逐行解析）
```python
# 定义函数：计算第m个月的兔子对数
def get_rabbit(m):
    # 出口：1月和2月都返回1
    if m in [1, 2]:  # 等价于 m == 1 or m == 2
        return 1
    # 规律：当前月 = 上月 + 上上月，自己调用自己算前两个月
    return get_rabbit(m - 1) + get_rabbit(m - 2)

# 测试：计算12个月的兔子对数
if __name__ == '__main__':
    print(get_rabbit(12))  # 输出：144（1年后有144对兔子）
```


### 🧠 递归过程拆解（以5月为例）
```
get_rabbit(5)  
= get_rabbit(4) + get_rabbit(3)  
= [get_rabbit(3) + get_rabbit(2)] + [get_rabbit(2) + get_rabbit(1)]  
= [get_rabbit(3) + 1] + [1 + 1]  # 触发1月和2月的出口  
= [get_rabbit(3) + 1] + 2  
= [get_rabbit(2) + get_rabbit(1) + 1] + 2  
= [1 + 1 + 1] + 2  # 再次触发出口  
= 3 + 2  
= 5  # 5月的兔子对数是5，和表格一致！  
```


## 📚 递归拓展：这些坑和技巧要知道

### 1. 递归的“软肋”：效率问题
递归虽然代码简洁，但可能重复计算。比如斐波那契数列中，计算`get_rabbit(5)`时，`get_rabbit(3)`被算了两次，`get_rabbit(2)`被算了三次……月份越大，重复越多，效率越低。  

**解决办法：记忆化递归**  
用字典存已经算过的结果，避免重复计算：  
```python
# 用字典缓存计算结果（键=月份，值=对数）
memo = {1: 1, 2: 1}

def get_rabbit_optimized(m):
    if m in memo:  # 已经算过，直接返回缓存的值
        return memo[m]
    # 没算过，计算后存到缓存
    result = get_rabbit_optimized(m-1) + get_rabbit_optimized(m-2)
    memo[m] = result
    return result

print(get_rabbit_optimized(100))  # 优化后能算很大的月份，不会卡
```


### 2. 递归vs迭代：什么时候用哪个？
- **递归**：代码简洁，适合“问题能拆分成更小同类问题”的场景（如阶乘、斐波那契、二叉树遍历），但调用次数多了会慢甚至报错。  
- **迭代（循环）**：效率高，适合解决递归能做的问题，比如用循环算阶乘：  
  ```python
  # 迭代版阶乘
  def factorial_iter(n):
      result = 1
      for i in range(1, n+1):
          result *= i
      return result

  print(factorial_iter(5))  # 输出：120
  ```  


### 3. 递归深度限制：别套太多层！
Python默认递归深度约为1000层，超过会报错（`RecursionError`）。比如计算`factorial(1000)`可能没事，但`factorial(10000)`就会崩溃。  

**解决办法**：  
- 能用迭代就用迭代；  
- 必须用递归时，可临时增加深度限制（不推荐，可能导致内存问题）：  
  ```python
  import sys
  sys.setrecursionlimit(100000)  # 把最大深度设为10万
  ```  


### 4. 更多递归经典案例
- **汉诺塔问题**：移动圆盘的步骤可以用递归拆解；  
- **文件夹遍历**：遍历文件夹下所有文件（文件夹里可能还有文件夹）；  
- **快速排序**：排序算法的核心思想是递归拆分数组。  


## 💡 总结：递归的核心心法
递归的关键就两句话：  
1. **找到出口**：什么时候可以直接返回结果，不用再调用自己？  
2. **找到规律**：当前问题如何拆分成“更小的同类问题”？  

记住这两点，遇到递归问题先画流程图（比如阶乘的拆分步骤、兔子每月的数量），慢慢就能培养递归思维啦！下次再见到“自己调用自己”的函数，你就不会慌了～ 😎