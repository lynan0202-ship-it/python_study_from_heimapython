# 集合与字典推导式综合示例：一行代码玩转集合与字典，附核心知识点注释
# 核心逻辑：和列表推导式原理相通，但利用了集合和字典的特性（去重、键值对）


# 一、集合推导式：用{}，元素唯一（自动去重），无序
# 格式：{元素 for 变量 in 可迭代对象 if 筛选条件}

# 1. 基础用法：生成带筛选的集合（筛选1-10中的奇数）
odd_set = {x for x in range(1, 11) if x % 2 != 0}
print("1-10的奇数集合：", odd_set)  # 输出类似 {1, 3, 5, 7, 9}（集合无序，顺序可能变）
# 解读：遍历1-10，通过if x%2!=0筛选奇数，用{}打包成集合


# 2. 核心特性：自动去重（处理重复数据超方便）
repeat_list = [2, 2, 3, 3, 4]
unique_squares = {num **2 for num in repeat_list}  # 计算平方后去重
print("去重后的平方集合：", unique_squares)  # 输出 {4, 9, 16}（2²=4、3²=9、4²=16，重复的被合并）


# 二、字典推导式：用{}，存键值对（key:value），键唯一（重复会覆盖）
# 格式：{key: value for 变量 in 可迭代对象 if 筛选条件}

# 1. 基础用法：生成键值关联的字典（键是数字，值是数字的3倍）
triple_dict = {n: n*3 for n in range(1, 4)}  # n是键，n*3是值
print("数字与3倍值的字典：", triple_dict)  # 输出 {1: 3, 2: 6, 3: 9}


# 2. 进阶：两个列表按索引拼接成字典（键值一一对应）
keys = ['name', 'city', 'hobby']  # 存放键的列表
values = ['Lisa', 'Beijing', 'reading']  # 存放值的列表
# 遍历索引i（0、1、2），用keys[i]当键，values[i]当值
info_dict = {keys[i]: values[i] for i in range(len(keys))}
print("列表拼接的信息字典：", info_dict)  # 输出 {'name': 'Lisa', 'city': 'Beijing', 'hobby': 'reading'}
# 注意：两个列表长度必须一致！否则会因索引越界报错


# 3. 注意点：键重复时，后面的会覆盖前面的
repeat_keys = ['a', 'a', 'b']
overwrite_dict = {k: k*2 for k in repeat_keys}  # 'a'出现两次
print("键重复的字典（覆盖后）：", overwrite_dict)  # 输出 {'a': 'aa', 'b': 'bb'}（后面的'a'覆盖了前面的）


# 4. 嵌套循环：生成复杂键的字典（键可以是元组等可哈希类型）
# 外层i取1、2，内层j取10、20，键是(i,j)，值是i+j
nested_dict = {(i, j): i + j for i in [1, 2] for j in [10, 20]}
print("嵌套循环生成的字典：", nested_dict)  # 输出 {(1,10):11, (1,20):21, (2,10):12, (2,20):22}
# 循环顺序：和普通嵌套一致（先外层i，再内层j）


# 🌟 关键区分与注意事项：
# 1. 集合vs字典推导式：
#    - 集合：{}内是单个元素（如{x for x in ...}）
#    - 字典：{}内是键值对（如{x: x*2 for x in ...}），必须有冒号
# 2. 唯一性：
#    - 集合：元素自动去重
#    - 字典：键重复会覆盖，保留最后一次出现的键值对
# 3. 可读性优先：逻辑复杂时（多条件/长计算），用普通循环更清晰，别硬用推导式

'''
1-10的奇数集合： {1, 3, 5, 7, 9}
去重后的平方集合： {16, 9, 4}
数字与3倍值的字典： {1: 3, 2: 6, 3: 9}
列表拼接的信息字典： {'name': 'Lisa', 'city': 'Beijing', 'hobby': 'reading'}
键重复的字典（覆盖后）： {'a': 'aa', 'b': 'bb'}
嵌套循环生成的字典： {(1, 10): 11, (1, 20): 21, (2, 10): 12, (2, 20): 22}
'''