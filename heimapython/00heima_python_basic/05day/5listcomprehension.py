# 列表推导式综合示例：用简洁代码覆盖核心知识点
# 记住核心逻辑：把"遍历→处理→筛选"浓缩成一行，格式灵活但有规律


# 1. 基础用法：直接生成序列（替代空列表+append）
# 格式：[要放入列表的元素 for 临时变量 in 可迭代对象]
basic_list = [i for i in range(6)]  # 遍历0-5，直接把i作为元素
print("基础生成（0-5）：", basic_list)  # 输出：[0, 1, 2, 3, 4, 5]


# 2. 带条件筛选：只保留符合条件的元素
# 格式：[元素 for 变量 in 可迭代对象 if 筛选条件]
even_list = [x for x in range(10) if x % 2 == 0]  # 遍历0-9，只保留偶数
print("筛选偶数（0-9）：", even_list)  # 输出：[0, 2, 4, 6, 8]


# 3. 带else的处理：对元素做"二选一"转换（不是筛选！）
# 格式：[元素1 if 条件 else 元素2 for 变量 in 可迭代对象]
# 注意：else和if是"二选一"逻辑，必须紧跟在元素后面，不能放最后
convert_list = [n if n > 3 else '小' for n in range(7)]  # 大于3保留数字，否则标'小'
print("二选一转换：", convert_list)  # 输出：['小', '小', '小', '小', 4, 5, 6]


# 4. 嵌套循环：生成多层遍历的组合（顺序和普通嵌套一致）
# 格式：[组合元素 for 外层变量 in 外层对象 for 内层变量 in 内层对象]
# 注意：先写外层循环，再写内层循环，顺序错则结果错
'''
nested_list = []  # 先创建空列表
# 外层循环：i依次取1、2
for i in [1, 2]:
    # 内层循环：对于每个i，j依次取'a'、'b'
    for j in ['a', 'b']:
        nested_list.append( (i, j) )  # 把(i,j)组成元组添加到列表

print(nested_list)  # 输出：[(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]
'''
nested_list = [(i, j) for i in [1, 2,3] for j in ['a', 'b']]  # 外层i取1/2，内层j取a/b
print("嵌套循环组合：", nested_list)  # 输出：[(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]
#嵌套循环组合： [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b'), (3, 'a'), (3, 'b')]

# 5. 处理非range的可迭代对象（如字符串、列表）
# 可迭代对象：字符串、列表等能被for遍历的都可以

my_list = ['A', 'b', 3, 'c']
lower_letters = [x for x in my_list if isinstance(x, str) and x.islower()]
print(lower_letters)  # 输出：['b', 'c']（先判断是否是字符串，再判断是否小写）

text = "Hello World"
lower_chars = [c for c in text if c.islower()]  # 从字符串中提取所有小写字母
print("提取小写字母：", lower_chars)  # 输出：['e', 'l', 'l', 'o', 'o', 'r', 'l', 'd']


# 🌟 关键注意点：
# 1. 筛选（只有if）vs 转换（if-else）：前者是"留或丢"，后者是"变A或变B"
# 2. 嵌套循环顺序：和普通for循环嵌套顺序完全一致，别写反
# 3. 可读性优先：逻辑复杂时（多条件/长计算），用普通循环更清晰，别硬套推导式
'''
基础生成（0-5）： [0, 1, 2, 3, 4, 5]
筛选偶数（0-9）： [0, 2, 4, 6, 8]
二选一转换： ['小', '小', '小', '小', 4, 5, 6]
嵌套循环组合： [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]
提取小写字母： ['e', 'l', 'l', 'o', 'o', 'r', 'l', 'd']
'''