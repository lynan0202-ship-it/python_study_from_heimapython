# 🐍 Python自定义模块大揭秘：从入门到玩转模块！


## 开场白：为啥要学模块？

想象一下：你写代码时，是不是总有些函数用了又用？比如计算面积、处理字符串… 总复制粘贴多麻烦！模块就像“代码积木盒”——把常用功能打包，下次直接“拿来用”，效率翻倍！今天咱们就把这个“积木盒”的玩法摸透～


## 一、模块的“身份证”：`__name__`属性

你有没有好奇过：一个模块怎么知道自己是“被直接运行”还是“被别人导入”的？比如你写了个`calc.py`，既能自己跑测试，又能被其他程序导入用里面的函数——这全靠`__name__`这个“身份标识”！


### 👉 核心规则：
- 当模块**自己运行**时（比如`python calc.py`），`__name__`会变成`"__main__"`（相当于“我是主角！”）
- 当模块**被导入**时（比如`import calc`），`__name__`会变成模块名（比如`"calc"`，相当于“我是配角～”）


### 🎬 经典用法：模块内测试代码
```python
# 模块：calc.py
def add(a, b):
    return a + b

# 只有自己运行时，才执行测试
if __name__ == "__main__":
    print("我自己跑啦！测试add(2,3)的结果：", add(2,3))  # 输出5
```
当其他程序`import calc`时，上面的测试代码完全不会执行，超贴心！


## 二、模块的“门禁卡”：`__all__`属性

假设你写了个模块，里面有10个函数，但只想让别人用其中3个——咋办？`__all__`就是“门禁卡列表”，只放行列表里的成员！


### 👉 核心作用：
限制`from 模块名 import *`这种“一锅端”式的导入，只让`__all__`里的变量/函数/类被导入（对其他导入方式无效哦～）


### 🚪 举个例子：
```python
# 模块：tool.py
__all__ = ["clean_str", "format_date"]  # 只允许这两个“出门”

def clean_str(s):  # 能被导入
    return s.strip()

def format_date(d):  # 能被导入
    return d.strftime("%Y-%m-%d")

def secret_func():  # 门禁外，不能被from tool import *导入
    print("这是内部函数，别碰！")
```
当别人用`from tool import *`时，只能拿到`clean_str`和`format_date`，`secret_func`会被“拦下来”～


## 三、重名了？别慌！多模块同名函数处理

就像班里有两个“小明”会 confusion 一样，两个模块里有同名函数也会出问题——后导入的会“覆盖”先导入的！


### 👉 问题现场：
```python
# 模块1：math1.py
def add(a, b):
    return a + b + 1  # 故意加1，区分一下

# 模块2：math2.py
def add(a, b):
    return a + b + 2  # 加2

# 你的代码
from math1 import add
from math2 import add  # 后导入，覆盖前面的add

print(add(1,2))  # 输出1+2+2=5，而不是math1的4！
```


### ✨ 解决办法：给函数“取外号”或“喊全名”
```python
# 方法1：用as取别名（推荐！）
from math1 import add as add_v1  # 叫add_v1
from math2 import add as add_v2  # 叫add_v2

print(add_v1(1,2))  # 4（math1的）
print(add_v2(1,2))  # 5（math2的）

# 方法2：通过模块名调用（清晰！）
import math1
import math2

print(math1.add(1,2))  # 4
print(math2.add(1,2))  # 5
```


## 四、拓展知识点：这些“坑”和“技巧”要知道！


### 1. 模块从哪找？导入路径大揭秘
Python导入模块时，会按这个顺序“寻宝”：
1. 当前运行脚本的目录（优先找“身边”的）
2. 系统环境变量`PYTHONPATH`里的路径
3. Python安装目录下的标准库（比如`os`、`sys`这些）

👉 小技巧：想让Python找到你的模块？可以手动加路径：
```python
import sys
sys.path.append("C:/my_modules")  # 把你的模块文件夹加入“寻宝地图”
import my_module  # 现在能找到了！
```


### 2. 小心“循环导入”这个坑！
啥是循环导入？比如：
- `a.py`里写了`import b`
- `b.py`里又写了`import a`

运行时会报错！因为Python加载模块时，发现“a依赖b，b又依赖a”，直接懵圈～

👉 怎么避免？
- 别让两个模块互相依赖！
- 把共同用到的代码拆成一个新模块（比如`common.py`），让a和b都导入它。
- 把导入语句放进函数里（延迟导入，不到用的时候不加载）。


### 3. 模块的“升级版”：包（Package）
当模块太多时，就需要用“包”来管理——包就是**带`__init__.py`文件的文件夹**！

```
my_package/          # 包文件夹
├── __init__.py      # 包的“配置文件”
├── tool1.py         # 模块1
└── tool2.py         # 模块2
```

`__init__.py`的作用：
- 告诉Python“这是个包，不是普通文件夹”
- 可以设置`__all__`控制`from my_package import *`导入哪些模块
- 可以放包的初始化代码（比如批量导入模块）


### 4. 模块的“缓存”：.pyc文件是啥？
第一次运行模块后，会在`__pycache__`文件夹里生成`.pyc`文件——这是编译后的“字节码”，下次运行时直接用，速度更快！不用管它，Python会自动管理～


### 5. 导入最佳实践（避坑指南）
- 少用`from 模块 import *`：容易重名，还不知道函数来自哪
- 推荐用`import 模块名`或`from 模块名 import 函数名`：清晰明了
- 模块名别和标准库重名！比如别起名`os.py`，会覆盖系统的`os`模块
- 定期清理没用的导入：让代码更清爽（IDE一般有这个功能～）


## 总结：模块玩得溜，代码写得快！

模块是Python“复用代码”的核心技能——用`__name__`做自测，用`__all__`控权限，重名了就用别名，再避开循环导入的坑～ 多动手试试，你也能把模块玩得明明白白！

下次写代码，别再复制粘贴啦，打包成模块，爽歪歪～ 😎